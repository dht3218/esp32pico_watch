/*
 * Copyright (c) 2024 EdgeImpulse Inc.
 *
 * Generated by Edge Impulse and licensed under the applicable Edge Impulse
 * Terms of Service. Community and Professional Terms of Service
 * (https://docs.edgeimpulse.com/page/terms-of-service) or Enterprise Terms of
 * Service (https://docs.edgeimpulse.com/page/enterprise-terms-of-service),
 * according to your product plan subscription (the “License”).
 *
 * This software, documentation and other associated files (collectively referred
 * to as the “Software”) is a single SDK variation generated by the Edge Impulse
 * platform and requires an active paid Edge Impulse subscription to use this
 * Software for any purpose.
 *
 * You may NOT use this Software unless you have an active Edge Impulse subscription
 * that meets the eligibility requirements for the applicable License, subject to
 * your full and continued compliance with the terms and conditions of the License,
 * including without limitation any usage restrictions under the applicable License.
 *
 * If you do not have an active Edge Impulse product plan subscription, or if use
 * of this Software exceeds the usage limitations of your Edge Impulse product plan
 * subscription, you are not permitted to use this Software and must immediately
 * delete and erase all copies of this Software within your control or possession.
 * Edge Impulse reserves all rights and remedies available to enforce its rights.
 *
 * Unless required by applicable law or agreed to in writing, the Software is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing
 * permissions, disclaimers and limitations under the License.
 */
// Generated on: 08.12.2024 11:29:34

#include <stdio.h>
#include <stdlib.h>
#include "edge-impulse-sdk/tensorflow/lite/c/builtin_op_data.h"
#include "edge-impulse-sdk/tensorflow/lite/c/common.h"
#include "edge-impulse-sdk/tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "edge-impulse-sdk/porting/ei_classifier_porting.h"

#if EI_CLASSIFIER_PRINT_STATE
#if defined(__cplusplus) && EI_C_LINKAGE == 1
extern "C" {
    extern void ei_printf(const char *format, ...);
}
#else
extern void ei_printf(const char *format, ...);
#endif
#endif

#if defined (__GNUC__)  /* GNU compiler */
#define ALIGN(X) __attribute__((aligned(X)))
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (_MSC_VER)
#define ALIGN(X) __declspec(align(X))
#elif defined (__TASKING__) /* TASKING Compiler */
#define ALIGN(X) __align(X)
#define DEFINE_SECTION(x) __attribute__(section(x)))
#elif defined (__ARMCC_VERSION) /* Arm Compiler */
#define ALIGN(X) __ALIGNED(x)
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (__ICCARM__) /* IAR Compiler */
#define ALIGN(x) __attribute__((aligned(x)))
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (__clang__) /* LLVM/Clang Compiler */
#define ALIGN(X) __ALIGNED(x)
#define DEFINE_SECTION(x) __attribute__((section(x)))
#endif

#ifndef EI_MAX_SCRATCH_BUFFER_COUNT
#ifndef CONFIG_IDF_TARGET_ESP32S3
#define EI_MAX_SCRATCH_BUFFER_COUNT 8
#else
#define EI_MAX_SCRATCH_BUFFER_COUNT 16
#endif // CONFIG_IDF_TARGET_ESP32S3
#endif // EI_MAX_SCRATCH_BUFFER_COUNT

#ifndef EI_MAX_OVERFLOW_BUFFER_COUNT
#define EI_MAX_OVERFLOW_BUFFER_COUNT 10
#endif // EI_MAX_OVERFLOW_BUFFER_COUNT

using namespace tflite;
using namespace tflite::ops;
using namespace tflite::ops::micro;

namespace {

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX) || defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
constexpr int kTensorArenaSize = 4112;
#else
constexpr int kTensorArenaSize = 3088;
#endif

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC)
#if defined (EI_TENSOR_ARENA_LOCATION)
#define STRINGIZE(x) #x
#define STRINGIZE_VALUE_OF(x) STRINGIZE(x)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) DEFINE_SECTION(STRINGIZE_VALUE_OF(EI_TENSOR_ARENA_LOCATION));
#else
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#endif
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX)
#pragma Bss(".tensor_arena")
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#pragma Bss()
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) __attribute__((section(".tensor_arena")));
#else
#define EI_CLASSIFIER_ALLOCATION_HEAP 1
uint8_t* tensor_arena = NULL;
#endif

static uint8_t* tensor_boundary;
static uint8_t* current_location;

template <int SZ, class T> struct TfArray {
  int sz; T elem[SZ];
};

enum used_operators_e {
  OP_RESHAPE, OP_CONV_2D, OP_MAX_POOL_2D, OP_FULLY_CONNECTED, OP_SOFTMAX,  OP_LAST
};

struct TensorInfo_t { // subset of TfLiteTensor used for initialization from constant memory
  TfLiteAllocationType allocation_type;
  TfLiteType type;
  void* data;
  TfLiteIntArray* dims;
  size_t bytes;
  TfLiteQuantization quantization;
};

typedef struct {
  TfLiteTensor tensor;
  int16_t index;
} TfLiteTensorWithIndex;

typedef struct {
  TfLiteEvalTensor tensor;
  int16_t index;
} TfLiteEvalTensorWithIndex;

TfLiteContext ctx{};
static const int MAX_TFL_TENSOR_COUNT = 4;
static TfLiteTensorWithIndex tflTensors[MAX_TFL_TENSOR_COUNT];
static const int MAX_TFL_EVAL_COUNT = 4;
static TfLiteEvalTensorWithIndex tflEvalTensors[MAX_TFL_EVAL_COUNT];
TfLiteRegistration registrations[OP_LAST];

namespace g0 {
const TfArray<2, int> tensor_dimension0 = { 2, { 1,429 } };
const TfArray<1, float> quant0_scale = { 1, { 0.03043549507856369, } };
const TfArray<1, int> quant0_zero = { 1, { 2 } };
const TfLiteAffineQuantization quant0 = { (TfLiteFloatArray*)&quant0_scale, (TfLiteIntArray*)&quant0_zero, 0 };
const ALIGN(16) int32_t tensor_data1[4] = { 1, 1, 33, 13, };
const TfArray<1, int> tensor_dimension1 = { 1, { 4 } };
const ALIGN(16) int32_t tensor_data2[4] = { 1, 33, 1, 16, };
const TfArray<1, int> tensor_dimension2 = { 1, { 4 } };
const ALIGN(16) int32_t tensor_data3[4] = { 1, 1, 17, 16, };
const TfArray<1, int> tensor_dimension3 = { 1, { 4 } };
const ALIGN(16) int32_t tensor_data4[4] = { 1, 17, 1, 16, };
const TfArray<1, int> tensor_dimension4 = { 1, { 4 } };
const ALIGN(16) int32_t tensor_data5[4] = { 1, 1, 9, 16, };
const TfArray<1, int> tensor_dimension5 = { 1, { 4 } };
const ALIGN(16) int32_t tensor_data6[4] = { 1, 9, 1, 16, };
const TfArray<1, int> tensor_dimension6 = { 1, { 4 } };
const ALIGN(16) int32_t tensor_data7[4] = { 1, 1, 5, 16, };
const TfArray<1, int> tensor_dimension7 = { 1, { 4 } };
const ALIGN(16) int32_t tensor_data8[4] = { 1, 5, 1, 16, };
const TfArray<1, int> tensor_dimension8 = { 1, { 4 } };
const ALIGN(8) int32_t tensor_data9[2] = { -1, 48, };
const TfArray<1, int> tensor_dimension9 = { 1, { 2 } };
const ALIGN(16) int32_t tensor_data10[5] = { -251, -318, -388, 1096, -218, };
const TfArray<1, int> tensor_dimension10 = { 1, { 5 } };
const TfArray<1, float> quant10_scale = { 1, { 0.00029242198797874153, } };
const TfArray<1, int> quant10_zero = { 1, { 0 } };
const TfLiteAffineQuantization quant10 = { (TfLiteFloatArray*)&quant10_scale, (TfLiteIntArray*)&quant10_zero, 0 };
const ALIGN(16) int8_t tensor_data11[5*48] = { 
  -46, 9, -32, 0, 50, -81, -3, -78, 7, 91, -67, 12, 77, -34, 92, -21, 49, 38, 37, -59, -22, 49, -6, 68, 14, 21, -6, -58, 68, -51, -17, -64, -18, -51, -49, -60, 53, -95, -30, 51, 3, -37, -15, -66, -4, 39, -58, -18, 
  -95, -40, 21, -32, 3, -44, 67, 37, 7, -36, -75, 64, -33, -15, -54, 18, -24, 104, -96, -92, 20, 45, 20, -53, 24, 57, -27, -28, -62, -49, 33, -78, 4, 66, -3, -6, -29, -90, -127, -27, 2, 6, 63, -26, -36, -16, -48, 24, 
  -61, -24, -53, 20, 14, 49, 69, -82, 79, -34, 42, 2, -51, -61, -61, -72, 74, -6, -126, 40, -36, 28, -27, 88, 59, 69, -35, 61, -46, 18, -36, -52, -27, -81, -2, -3, -63, -1, 10, -123, -114, -100, -99, 77, 2, -23, 24, -60, 
  -15, 10, 29, -73, 28, 43, -20, 48, -21, -55, -34, -44, -43, -50, -2, 60, -30, -54, 2, 68, 45, -11, -21, -7, -82, -41, 21, -11, 4, 54, 4, -11, -13, -21, -86, -41, -47, 99, 90, -103, -49, -40, 31, 95, -5, 63, -14, 104, 
  93, -29, -23, -96, 44, -53, -57, -38, -7, -52, 91, -14, -70, -79, 11, 38, -19, 29, 63, -54, 39, 50, -4, -32, -81, -30, -33, 80, -53, -9, 18, 73, -100, -7, 34, -3, -29, 1, 27, 17, -60, -28, -7, -90, -16, -31, 14, 39, 
};
const TfArray<2, int> tensor_dimension11 = { 2, { 5,48 } };
const TfArray<1, float> quant11_scale = { 1, { 0.0051831826567649841, } };
const TfArray<1, int> quant11_zero = { 1, { 0 } };
const TfLiteAffineQuantization quant11 = { (TfLiteFloatArray*)&quant11_scale, (TfLiteIntArray*)&quant11_zero, 0 };
const ALIGN(16) int32_t tensor_data12[16] = { -585, -380, 136, 202, -693, 653, 361, 556, -367, -404, -122, 552, -297, -473, -205, 378, };
const TfArray<1, int> tensor_dimension12 = { 1, { 16 } };
const TfArray<16, float> quant12_scale = { 16, { 0.00023262707691174001, 0.00027708639390766621, 0.00027505838079378009, 0.00024480719002895057, 0.00015956083370838314, 0.00021736773487646133, 0.00021431065397337079, 0.00025713900686241686, 0.00024108379147946835, 0.00023243539908435196, 0.00024234234297182411, 0.00020084770221728832, 0.00020210391085129231, 0.00014879342052154243, 0.00022634306515101343, 0.00021021040447521955, } };
const TfArray<16, int> quant12_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant12 = { (TfLiteFloatArray*)&quant12_scale, (TfLiteIntArray*)&quant12_zero, 0 };
const ALIGN(16) int8_t tensor_data13[16*1*4*16] = { 
  /* [0][0][][] */ 51,43,-37,-61,-38,-48,-18,74,95,-62,-64,-41,86,119,-91,-4, 24,-25,-39,-35,-24,-62,-24,2,-20,-39,3,-86,-44,-89,40,28, -80,6,-48,21,-21,24,-33,-66,-23,13,54,0,6,-21,38,-22, 73,-37,127,47,6,-7,-91,-80,-77,11,34,-73,12,-10,74,-41, 
  /* [1][0][][] */ -40,10,-30,49,31,-39,-28,69,4,-28,-52,100,1,15,5,-81, 47,6,59,13,15,-8,-60,-27,10,-26,-2,56,22,-7,-58,-97, -16,-5,66,-5,-29,-39,-50,-14,-19,50,-12,5,-50,35,-74,-15, 5,-112,-119,12,-40,2,-86,-57,-43,-127,-105,-115,-95,-94,-55,-80, 
  /* [2][0][][] */ 36,-110,-34,23,84,-24,-26,-1,-13,-7,12,12,-71,0,-11,-28, 30,-50,28,44,-63,44,-64,-22,-23,43,-24,-96,48,-18,101,-46, -24,21,13,31,44,-33,-39,-44,-127,32,29,56,-10,6,46,-32, 32,55,-52,3,-7,21,7,-4,20,7,-65,53,9,46,-47,22, 
  /* [3][0][][] */ -22,-37,-27,9,-31,34,-14,-86,64,52,35,38,-12,19,-55,41, -15,2,57,-25,-45,44,58,12,17,39,64,-21,-27,20,-31,119, -97,-41,-40,-8,45,42,20,4,62,-76,-74,-38,7,5,-19,88, -127,-79,-106,-23,-80,5,29,-75,37,-33,22,-46,18,-77,55,56, 
  /* [4][0][][] */ -79,41,45,-62,-1,39,53,-102,-11,-57,-90,-67,-4,42,7,1, -57,-124,-74,-100,-76,-13,50,-18,-127,-111,-7,-67,14,-24,5,33, 47,20,8,44,-41,-11,-33,-68,-10,-72,-47,22,-25,-126,0,-38, 33,64,10,-82,55,-29,32,4,40,-65,-92,27,-94,34,-13,37, 
  /* [5][0][][] */ -65,-49,-10,31,30,-16,64,41,53,25,40,50,-110,46,-2,-46, -91,-40,-85,-65,-24,37,50,-90,78,-15,-37,31,87,-86,100,-9, 127,-11,28,10,-105,19,20,-92,9,86,46,11,-33,68,-84,14, -49,81,-57,-37,-115,-50,86,33,-56,42,35,-3,-106,55,-39,44, 
  /* [6][0][][] */ -23,76,-36,32,-6,30,-17,-29,14,89,15,-27,-83,47,25,50, -51,80,-88,-47,-19,-19,58,-102,49,-67,6,24,53,-33,66,2, -49,9,-38,89,35,-12,0,24,18,-110,-41,16,59,-52,-113,-92, 74,-33,46,15,-19,40,104,-26,48,-26,76,112,11,-15,-127,22, 
  /* [7][0][][] */ -9,-27,-21,-28,26,-27,-11,-34,83,-93,-9,-62,49,-16,61,-73, 53,-9,-41,15,-91,6,-20,-6,25,-3,10,-25,-12,-100,25,127, 19,65,-7,8,-44,23,68,-78,-29,41,-24,-6,4,-42,43,42, -38,78,24,4,-55,12,-30,79,-5,64,-14,30,25,27,39,-33, 
  /* [8][0][][] */ -18,28,117,-19,-45,-27,49,-10,127,-65,-39,29,76,-24,-29,1, 40,-28,-11,0,17,11,-12,-50,45,-55,39,47,38,-58,-82,54, -27,2,27,52,-87,61,77,-78,-101,28,-23,29,-91,-27,16,83, 120,-19,16,57,-42,-25,56,-7,-14,37,-25,34,-38,-53,-43,-56, 
  /* [9][0][][] */ 43,-32,50,-17,91,21,9,23,39,-11,-57,32,87,-59,-28,-14, 25,-38,83,7,99,7,18,-10,40,-43,55,65,-37,-57,-67,77, 2,-95,56,-52,5,13,-80,-5,53,-10,-24,54,-43,97,-80,-9, 17,-8,3,-3,-38,-55,-39,-78,-42,-52,-31,-75,93,-34,-23,-127, 
  /* [10][0][][] */ 6,22,-24,-51,-25,-70,-78,-1,-18,-12,31,58,64,114,-72,-71, 60,48,-14,58,-43,-22,-122,95,24,-35,-32,-67,-7,-44,45,-21, -47,-67,-110,-15,-40,-56,-11,6,-82,-15,38,-37,-17,25,12,-28, -39,-39,-37,12,59,-43,48,-127,-27,-74,-59,-60,-80,10,87,-50, 
  /* [11][0][][] */ -11,-15,-76,-19,-33,-28,104,-11,-78,11,127,-8,-36,-23,-41,86, 28,49,-58,53,119,54,-23,-51,27,-73,0,-84,-63,-32,75,69, 126,28,67,25,48,1,69,-75,-127,45,-78,-16,-114,24,20,-3, -25,-18,-48,30,74,-31,65,3,-24,-20,-95,103,90,-34,-100,-27, 
  /* [12][0][][] */ 39,19,109,-41,76,41,49,44,44,-57,41,11,-122,-92,-101,53, -12,-29,14,16,59,-63,-67,59,60,-69,-21,58,-94,21,-90,48, -20,-16,-60,8,35,15,20,-47,29,-54,-77,-4,81,-79,9,-50, -104,-55,52,-3,46,49,-127,-24,29,-80,-35,-55,24,20,32,43, 
  /* [13][0][][] */ -37,-78,7,-33,-70,18,-89,-111,-8,1,-44,25,-69,-97,-32,50, 2,38,-118,-8,-29,-9,55,-56,-76,-42,56,32,51,-80,51,-52, -87,-37,-9,54,-70,-34,-49,-49,-87,12,-107,-56,74,51,-86,42, -94,-31,-75,56,-79,14,-57,79,-22,-127,-90,41,-65,42,-57,61, 
  /* [14][0][][] */ -103,2,29,32,-30,-24,-9,-71,-50,8,-111,-32,6,-43,-10,9, -54,23,19,34,60,45,31,39,-34,-59,11,40,-104,-98,-62,31, 73,-81,-41,31,89,-16,-102,-6,-21,41,-2,-36,7,60,-91,-32, -40,-33,-61,-4,-64,21,45,-27,11,-39,-29,-90,54,49,45,-127, 
  /* [15][0][][] */ -10,0,-17,38,-10,35,-114,64,-99,36,94,-127,-33,-36,39,-37, -63,40,-116,44,-76,18,-80,-9,-57,-67,56,-111,-30,-27,-11,-43, -23,21,15,-45,52,-41,8,-14,1,56,-22,-16,14,20,77,-102, 26,52,-5,4,-15,-61,3,93,-73,120,32,38,4,50,3,-66, 
};
const TfArray<4, int> tensor_dimension13 = { 4, { 16,1,4,16 } };
const TfArray<16, float> quant13_scale = { 16, { 0.0034266735892742872, 0.0040815738029778004, 0.0040517007000744343, 0.0036060907877981663, 0.0023503836710005999, 0.0032018984202295542, 0.0031568666454404593, 0.0037877422291785479, 0.0035512438043951988, 0.0034238500520586967, 0.0035697827115654945, 0.0029585529118776321, 0.0029770573601126671, 0.0021917761769145727, 0.0033341080415993929, 0.0030964685138314962, } };
const TfArray<16, int> quant13_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant13 = { (TfLiteFloatArray*)&quant13_scale, (TfLiteIntArray*)&quant13_zero, 0 };
const ALIGN(16) int32_t tensor_data14[16] = { 499, 556, 244, -847, -206, -801, 19, 156, -354, 1191, 95, 123, -289, 618, 1106, 61, };
const TfArray<1, int> tensor_dimension14 = { 1, { 16 } };
const TfArray<16, float> quant14_scale = { 16, { 0.00013979512732475996, 0.00013510434655472636, 0.0001326158526353538, 0.00010267180914524943, 0.00013418526214081794, 0.00012074568076059222, 0.00013485630915965885, 0.00012632810103241354, 0.00021711719455197453, 0.00019240744586568326, 0.00014633579121436924, 0.00015278121281880885, 0.00019141229859087616, 0.00015033641830086708, 0.0001929633435793221, 0.00022650261234957725, } };
const TfArray<16, int> quant14_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant14 = { (TfLiteFloatArray*)&quant14_scale, (TfLiteIntArray*)&quant14_zero, 0 };
const ALIGN(16) int8_t tensor_data15[16*1*4*16] = { 
  /* [0][0][][] */ 43,62,87,-123,2,16,-9,-56,12,-7,-19,60,16,61,-13,-17, 38,-68,-22,-93,-10,32,-32,-9,58,-63,-66,-2,8,91,97,-69, -32,-80,58,-35,48,-48,-28,-42,-38,-85,-103,6,57,-38,-28,10, -34,-43,-90,-62,-18,9,-127,-21,11,-33,-26,-89,60,26,-12,-104, 
  /* [1][0][][] */ 81,-45,-62,-10,85,-35,30,5,9,-4,-45,-103,42,-88,35,-53, -62,2,-91,43,64,-107,65,-30,-48,16,-13,-21,-4,-93,22,31, 49,44,-79,1,53,-5,-42,59,8,-33,-80,127,1,-83,-18,53, 77,61,57,20,49,-69,37,-65,-80,43,-6,-17,12,-25,-67,59, 
  /* [2][0][][] */ -6,37,84,-44,50,87,-54,-76,-56,-33,-26,7,28,63,91,-113, 62,65,-7,-2,-33,-102,-41,-127,29,-70,-61,-105,51,91,62,11, 35,8,-42,-102,-19,-25,-6,-68,-101,-58,-77,-59,23,63,-31,68, -47,-58,-44,-33,-2,38,-31,7,-98,22,49,-34,5,-74,-73,83, 
  /* [3][0][][] */ -10,-3,-90,-105,-35,15,-59,-73,24,5,-59,26,33,30,-19,-99, -22,-37,-39,-127,-51,47,24,-103,-48,-42,-49,47,8,-59,-65,50, -14,-72,37,33,-1,-41,-28,-94,-101,16,28,90,109,-31,7,11, -23,-43,6,-93,-54,-51,-37,-73,-85,-78,-45,-26,-92,-13,-75,18, 
  /* [4][0][][] */ 34,-25,92,99,-39,-63,96,12,42,-1,-58,92,38,38,-58,81, 7,46,-10,-63,-66,-80,80,-79,13,31,-41,92,41,7,22,25, 0,-71,32,-61,-78,56,1,-84,40,-62,24,-107,-3,35,13,84, -64,-64,32,53,-46,52,-6,-14,39,84,127,-23,68,-81,22,0, 
  /* [5][0][][] */ -26,-63,-14,-13,-10,-45,-21,31,-81,-99,-5,62,46,-25,9,-48, -20,-34,-22,0,-27,-85,-56,-12,-38,-43,32,-13,-53,-72,-41,-48, 15,-92,-28,-80,-41,19,-43,-39,-31,-54,-29,-12,42,127,16,34, -25,-25,-76,-33,-84,-16,-16,17,-41,-57,16,-54,38,81,-82,-68, 
  /* [6][0][][] */ 12,-61,-84,66,-7,83,-127,38,-14,-111,-25,26,-26,20,40,-1, 42,-3,6,-14,-45,23,-21,-47,-58,-74,58,-8,-37,6,-31,-36, 27,23,-50,39,-21,47,33,-88,-24,78,12,-4,-48,-66,79,47, 92,77,-24,-46,-99,-79,70,-42,-87,58,-100,22,29,0,42,36, 
  /* [7][0][][] */ 50,-50,-65,-6,28,-76,-62,15,-3,-40,49,-74,29,3,34,-65, 39,75,93,36,127,-7,35,10,7,-11,26,-61,-62,-78,2,29, 20,-33,102,20,-57,37,-42,13,-43,-51,-19,105,58,-47,-100,75, -120,43,40,5,-74,74,31,97,82,-17,93,119,-59,-66,-67,38, 
  /* [8][0][][] */ 63,-24,-2,-30,-22,-38,59,-49,-31,32,37,127,4,-18,26,59, -17,35,-40,-20,-25,41,18,-6,-7,46,-27,84,-20,-45,-11,47, -50,3,-24,18,16,39,-3,40,25,28,19,42,-35,24,-38,-4, -30,-18,-23,45,-18,54,-60,18,-29,-23,-36,-33,-3,62,-58,-24, 
  /* [9][0][][] */ -20,27,44,-18,23,-12,-27,20,52,-8,-51,-84,37,-3,71,-29, 43,3,40,0,-13,-17,-44,19,55,-36,-52,-92,-18,19,83,-66, 6,30,-5,11,41,-20,14,40,17,33,42,76,-16,-61,-32,-51, 127,52,-44,20,52,-40,13,-2,29,38,25,125,11,-24,20,65, 
  /* [10][0][][] */ -67,71,70,14,-64,42,-127,48,31,-66,-27,-85,10,82,30,-114, 8,51,108,86,-63,51,-43,56,6,-78,-30,10,-45,21,6,-23, 33,-5,-68,37,30,27,0,-13,-5,9,69,64,-39,-28,73,13, -16,-26,15,10,-104,-71,10,-10,49,0,49,95,54,11,0,-55, 
  /* [11][0][][] */ 76,73,-23,8,-14,14,73,-61,-92,14,-71,88,-11,-24,-71,15, 46,14,18,-23,-55,-19,-34,-52,-42,-47,-34,-9,-52,-14,20,77, 44,43,31,-63,-15,67,54,-44,-16,-17,1,44,29,-45,22,-20, 64,67,5,-92,10,-29,-3,-51,21,12,94,-127,-27,-8,78,28, 
  /* [12][0][][] */ 24,8,-45,-64,-16,39,57,-29,-17,56,26,-17,-31,-29,-47,77, -10,4,-32,-30,7,35,24,-28,29,-13,13,49,-6,-28,-28,24, -56,43,-3,-6,85,4,-68,37,35,-25,-24,-47,-27,127,-6,-54, -23,43,3,-29,64,-33,-89,0,-71,-79,26,-51,30,65,35,-88, 
  /* [13][0][][] */ -42,26,39,8,33,-127,52,-94,-51,-36,-18,-80,34,-66,73,45, 33,-82,-107,-39,30,31,-56,-46,2,-47,-59,-109,52,-94,34,-29, 28,-102,-74,-18,91,47,28,22,-13,44,85,2,1,-33,12,-22, -32,89,45,74,30,14,-2,-12,53,114,-12,16,30,-55,-24,-31, 
  /* [14][0][][] */ -45,-13,17,59,63,-9,8,43,65,17,120,-17,-6,-30,-81,-31, -33,-3,52,28,3,-36,52,19,77,82,27,127,-3,19,-42,-15, 11,-29,0,6,75,12,-42,-37,52,51,-48,7,-32,9,-22,-50, 54,34,3,-35,-5,-72,-4,-51,-19,-25,-46,28,-13,-2,1,12, 
  /* [15][0][][] */ 25,3,3,88,36,56,-83,19,-50,-66,-62,56,29,127,-57,-77, -23,-14,23,6,15,11,-28,-7,-59,-35,-30,45,-25,-8,-11,-30, 2,-13,-48,-6,-7,12,-38,-38,-48,-6,18,67,9,-57,39,36, -26,-38,-86,-67,-36,35,-44,1,-9,31,-8,33,19,-33,43,6, 
};
const TfArray<4, int> tensor_dimension15 = { 4, { 16,1,4,16 } };
const TfArray<16, float> quant15_scale = { 16, { 0.0033602891489863396, 0.0032475357875227928, 0.0031877192668616772, 0.0024679470807313919, 0.0032254434190690517, 0.0029023929964751005, 0.0032415736932307482, 0.0030365791171789169, 0.0052188984118402004, 0.0046249441802501678, 0.0035175085067749023, 0.0036724389065057039, 0.0046010236255824566, 0.0036136726848781109, 0.0046383063308894634, 0.0054444978013634682, } };
const TfArray<16, int> quant15_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant15 = { (TfLiteFloatArray*)&quant15_scale, (TfLiteIntArray*)&quant15_zero, 0 };
const ALIGN(16) int32_t tensor_data16[16] = { -159, -346, -512, -47, 543, -1232, 173, -530, -194, 498, -138, 1146, -835, 127, -408, -95, };
const TfArray<1, int> tensor_dimension16 = { 1, { 16 } };
const TfArray<16, float> quant16_scale = { 16, { 0.00012714311014860868, 0.00012228084960952401, 0.00012359273387119174, 9.9805591162294149e-05, 0.00012864220479968935, 0.00011008113506250083, 0.00013099139323458076, 0.0001175436336779967, 0.00012270844308659434, 0.00010808685328811407, 0.00010806108184624463, 0.00018938850553240627, 8.6372514488175511e-05, 0.00013860363105777651, 0.00011524530418682843, 0.00011290251859463751, } };
const TfArray<16, int> quant16_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant16 = { (TfLiteFloatArray*)&quant16_scale, (TfLiteIntArray*)&quant16_zero, 0 };
const ALIGN(16) int8_t tensor_data17[16*1*3*16] = { 
  /* [0][0][][] */ 36,40,53,59,-40,-23,-30,-8,-22,10,-22,-32,-33,0,-1,-114, 4,8,7,66,-60,-116,43,11,-12,4,33,-33,39,16,69,-90, -28,-32,-13,9,-68,-60,111,-67,7,-3,127,-9,57,69,100,-74, 
  /* [1][0][][] */ -31,76,20,43,-14,-66,-25,-31,-95,17,-41,20,48,71,108,-1, 50,-11,42,-88,2,-60,-27,-34,-35,47,47,-63,-61,-34,108,-60, -11,70,79,-34,46,24,31,-25,58,13,20,-127,-28,33,-17,37, 
  /* [2][0][][] */ -35,55,-14,-26,45,-105,56,2,77,40,11,17,-26,-94,-6,127, -78,10,54,-73,11,-57,63,-39,65,58,-55,-48,-85,22,38,103, -34,28,-10,-91,79,11,-27,-84,-30,-94,82,-3,5,8,-32,43, 
  /* [3][0][][] */ -37,6,38,-86,127,71,-32,106,29,-95,-102,104,66,-26,-2,32, -96,-37,-95,-4,23,26,56,71,79,-107,27,-1,20,-50,-94,-46, -18,8,-113,-31,-53,-25,2,76,-54,38,105,18,-46,-51,-29,83, 
  /* [4][0][][] */ -22,23,-37,-19,-60,7,-7,37,-88,10,-66,-9,-28,15,24,22, 24,28,58,7,-24,107,3,-5,-22,-90,-25,73,32,47,74,-29, -26,111,-4,-8,-46,71,-33,-8,-49,-21,-15,59,127,15,85,-10, 
  /* [5][0][][] */ -84,37,27,2,13,-112,-57,127,-34,-39,-68,-113,87,46,-91,-61, -53,30,4,-4,44,13,-59,83,2,30,-54,-82,59,19,-86,-50, -78,8,-2,41,72,45,-19,106,20,81,-110,15,-77,50,-40,-6, 
  /* [6][0][][] */ 28,-13,14,89,-83,2,38,49,43,-67,51,-87,28,42,34,22, -33,-86,-49,68,-39,8,-40,-5,-44,-62,94,-21,-53,56,7,-26, 32,-91,-72,-45,-4,-3,-6,29,21,9,60,-127,-50,37,-3,27, 
  /* [7][0][][] */ -13,70,-22,-90,-22,109,50,14,41,29,-20,90,29,16,37,77, -58,-31,-127,-36,53,41,47,14,-19,30,-48,-52,97,-60,47,30, -82,64,-24,21,-25,56,39,26,-59,-55,-33,-15,-69,-91,-65,64, 
  /* [8][0][][] */ 14,-113,56,74,-9,12,65,37,-20,-35,-50,15,-9,-6,-126,127, -33,-77,54,37,35,15,14,-24,18,-67,58,-26,-61,-73,-34,67, -5,0,-13,-12,12,35,2,0,-86,-88,-49,8,10,7,18,70, 
  /* [9][0][][] */ 13,-101,31,127,-85,87,62,67,6,-21,-42,-57,8,39,-49,61, -45,-60,-58,118,-93,90,23,87,-22,49,-21,-16,-92,109,-8,74, -70,-99,23,-37,-44,-34,-51,2,-30,-31,71,-57,-32,15,-15,-68, 
  /* [10][0][][] */ -77,-124,-71,9,3,-28,1,-19,-74,-107,-93,-53,-26,-14,-55,6, -78,-74,-51,79,-65,82,14,88,15,-20,-54,106,0,74,68,110, 65,-74,36,6,-43,-5,47,127,49,89,-107,-70,-50,27,-98,52, 
  /* [11][0][][] */ -9,26,-26,23,32,48,5,-24,-4,-42,53,22,127,-50,48,-9, -30,-10,-48,34,5,-8,46,-5,47,1,47,-58,37,31,1,-55, -57,-48,-87,-21,-17,-77,-12,-54,-32,-63,-46,-54,-93,-40,-46,-44, 
  /* [12][0][][] */ -113,24,-89,68,-48,-27,49,-42,34,-38,-87,-36,-106,18,-104,-63, 24,39,44,7,10,-118,-74,11,-127,-70,-38,-40,15,30,-29,-2, 37,-12,-44,-22,-1,-82,-23,-62,-19,9,33,-18,-7,-60,-13,42, 
  /* [13][0][][] */ 2,26,-13,-48,-27,28,-58,8,29,69,-53,14,-73,-100,-37,-72, 1,59,118,-89,75,-31,-91,72,-17,29,-40,1,29,-46,-21,-15, -7,47,-52,-127,-20,9,-42,64,4,-81,60,-110,48,-82,-12,-5, 
  /* [14][0][][] */ 84,-15,109,11,22,34,-20,-127,-106,126,47,27,-61,-78,-13,-7, 76,-57,59,67,25,-56,12,-98,45,-37,6,-36,-113,36,28,-121, 40,4,13,58,54,19,69,-26,-49,61,3,-47,-1,-17,-13,40, 
  /* [15][0][][] */ 64,-19,-33,-28,-81,-71,-19,40,-4,-49,119,-52,28,3,47,-29, -13,-127,-22,-44,-117,-53,19,52,18,-74,67,-80,-13,69,0,-2, -21,-92,44,-22,-44,36,-4,76,69,-51,38,-126,15,36,-84,-42, 
};
const TfArray<4, int> tensor_dimension17 = { 4, { 16,1,3,16 } };
const TfArray<16, float> quant17_scale = { 16, { 0.0037725458387285471, 0.0036282744258642197, 0.0036672002170234919, 0.0029613964725285769, 0.0038170262705534697, 0.0032662886660546064, 0.0038867304101586342, 0.0034877134021371603, 0.0036409616004675627, 0.0032071149908006191, 0.0032063503749668598, 0.0056194690987467766, 0.0025628148578107357, 0.0041125980205833912, 0.0034195182379335165, 0.0033500038553029299, } };
const TfArray<16, int> quant17_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant17 = { (TfLiteFloatArray*)&quant17_scale, (TfLiteIntArray*)&quant17_zero, 0 };
const ALIGN(16) int32_t tensor_data18[16] = { 422, 708, 209, 201, -190, 433, 101, -1106, -599, -1195, -322, 578, 1121, -1198, 314, -604, };
const TfArray<1, int> tensor_dimension18 = { 1, { 16 } };
const TfArray<16, float> quant18_scale = { 16, { 9.9478427728172392e-05, 0.00015387707389891148, 9.668571874499321e-05, 0.00014512805500999093, 0.00010271929204463959, 0.00012022891314700246, 8.9244771515950561e-05, 0.00013673180365003645, 0.00010581129026832059, 0.00011849024303955957, 0.00011089107283623889, 0.00013216960360296071, 0.00010077411570819095, 0.00010320713772671297, 0.00013898413453716785, 0.00011027762229787186, } };
const TfArray<16, int> quant18_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant18 = { (TfLiteFloatArray*)&quant18_scale, (TfLiteIntArray*)&quant18_zero, 0 };
const ALIGN(16) int8_t tensor_data19[16*1*3*13] = { 
  /* [0][0][][] */ -17,-68,-126,127,-58,68,-3,-36,-45,-9,44,52,32, -54,-20,-84,34,30,62,-11,5,-72,28,68,22,-1, -77,-10,93,62,-69,48,-53,29,-24,-31,-42,27,44, 
  /* [1][0][][] */ -50,-38,-96,-127,31,21,44,11,-51,60,6,14,15, -19,9,-2,-36,6,14,-32,50,-21,-16,52,0,-12, 47,-9,-14,-62,33,-5,-24,36,13,-41,-42,-21,-6, 
  /* [2][0][][] */ 48,-57,-127,72,13,59,-44,-60,0,43,71,73,-91, -85,7,-89,-26,124,80,-86,-1,-12,-70,35,123,-5, -71,68,-106,7,16,-9,-110,-70,-66,-121,-82,13,-28, 
  /* [3][0][][] */ -44,-15,127,5,25,10,-50,19,78,-8,51,73,27, 21,42,86,31,-28,-16,-62,-69,2,13,54,56,6, -21,66,124,19,-10,-14,30,-30,32,32,10,-20,-13, 
  /* [4][0][][] */ 87,11,-57,-85,9,-8,-30,10,-3,-105,3,-81,-50, 10,99,-79,-127,-17,18,-107,57,45,-90,24,30,33, 0,-1,-42,6,-43,21,9,62,12,-80,-84,41,-47, 
  /* [5][0][][] */ 41,-61,111,-47,6,9,-60,-51,-38,16,69,73,-16, 71,-95,11,-20,49,49,64,-57,-6,-8,-20,-69,-65, -6,-33,82,4,127,36,-41,-99,-26,-39,32,-15,-5, 
  /* [6][0][][] */ 9,-64,35,-79,-57,28,-34,83,34,-24,-12,-27,-88, 127,-10,24,0,-11,-92,-103,-48,100,-36,88,-6,-4, -41,65,-4,35,-73,-55,-65,11,-36,82,-10,-48,55, 
  /* [7][0][][] */ 51,63,127,-61,-22,78,11,-60,-3,-26,-24,-7,44, 15,75,55,-37,-19,79,10,-4,-62,-50,43,22,21, 42,21,35,-24,-31,71,-32,-25,34,-45,37,80,-15, 
  /* [8][0][][] */ 69,54,9,-42,-67,15,6,33,-64,-80,1,53,-5, -38,-21,76,-27,-50,-19,-56,26,-46,-68,57,-47,74, 72,127,47,29,19,17,-78,23,-54,24,-27,34,31, 
  /* [9][0][][] */ -72,-58,45,65,30,-12,-105,37,-18,22,-24,127,-31, -22,-73,-73,39,59,-30,-58,10,28,59,80,49,-36, -75,-3,-75,-55,73,-8,-42,-8,77,-29,74,25,18, 
  /* [10][0][][] */ 99,-7,-59,60,-97,-76,2,4,2,76,8,-80,-20, 14,-9,-33,49,-98,-75,69,1,-41,100,-22,-108,4, 61,80,-79,96,-26,-30,114,19,-112,127,47,-93,60, 
  /* [11][0][][] */ -45,-127,-56,-48,0,20,44,7,31,0,19,35,13, -52,-79,82,-12,109,61,67,-49,-21,57,-21,20,-16, -55,-126,72,4,72,72,71,-48,-3,55,-3,-9,-14, 
  /* [12][0][][] */ -28,121,70,-19,18,82,99,-24,-87,-8,-15,-26,30, 33,-38,52,-46,-72,86,53,47,12,-12,-32,-68,127, 76,-26,1,-21,78,28,123,-40,82,115,-65,-57,75, 
  /* [13][0][][] */ 45,71,92,0,-34,43,21,-43,47,59,-14,-26,-46, 19,61,127,-40,-56,7,5,-103,77,-3,-83,-2,-63, 40,-29,53,24,-71,52,20,-26,63,12,-25,-61,73, 
  /* [14][0][][] */ 24,-12,14,-22,-69,-22,-29,-19,74,18,50,11,45, 28,-23,-46,-57,6,45,-19,-46,60,81,-25,-6,63, 65,-44,-18,63,-82,7,127,33,-20,86,14,-40,72, 
  /* [15][0][][] */ 43,50,85,8,-39,-93,-101,7,39,-50,80,37,-63, 85,127,-16,27,-68,-60,-78,41,-11,-35,116,70,-114, 11,23,-24,-77,2,-31,-104,36,22,-36,34,27,2, 
};
const TfArray<4, int> tensor_dimension19 = { 4, { 16,1,3,13 } };
const TfArray<16, float> quant19_scale = { 16, { 0.0032685003243386745, 0.0050558424554765224, 0.0031767420005053282, 0.0047683818265795708, 0.0033749835565686226, 0.003950286190956831, 0.0029322595801204443, 0.0044925110414624214, 0.0034765752498060465, 0.0038931597955524921, 0.003643478499725461, 0.0043426137417554855, 0.0033110720105469227, 0.0033910123165696859, 0.004566514864563942, 0.0036233228165656328, } };
const TfArray<16, int> quant19_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant19 = { (TfLiteFloatArray*)&quant19_scale, (TfLiteIntArray*)&quant19_zero, 0 };
const TfArray<4, int> tensor_dimension20 = { 4, { 1,1,33,13 } };
const TfArray<1, float> quant20_scale = { 1, { 0.03043549507856369, } };
const TfArray<1, int> quant20_zero = { 1, { 2 } };
const TfLiteAffineQuantization quant20 = { (TfLiteFloatArray*)&quant20_scale, (TfLiteIntArray*)&quant20_zero, 0 };
const TfArray<4, int> tensor_dimension21 = { 4, { 1,1,33,16 } };
const TfArray<1, float> quant21_scale = { 1, { 0.033702205866575241, } };
const TfArray<1, int> quant21_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant21 = { (TfLiteFloatArray*)&quant21_scale, (TfLiteIntArray*)&quant21_zero, 0 };
const TfArray<4, int> tensor_dimension22 = { 4, { 1,33,1,16 } };
const TfArray<1, float> quant22_scale = { 1, { 0.033702205866575241, } };
const TfArray<1, int> quant22_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant22 = { (TfLiteFloatArray*)&quant22_scale, (TfLiteIntArray*)&quant22_zero, 0 };
const TfArray<4, int> tensor_dimension23 = { 4, { 1,17,1,16 } };
const TfArray<1, float> quant23_scale = { 1, { 0.033702205866575241, } };
const TfArray<1, int> quant23_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant23 = { (TfLiteFloatArray*)&quant23_scale, (TfLiteIntArray*)&quant23_zero, 0 };
const TfArray<4, int> tensor_dimension24 = { 4, { 1,1,17,16 } };
const TfArray<1, float> quant24_scale = { 1, { 0.033702205866575241, } };
const TfArray<1, int> quant24_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant24 = { (TfLiteFloatArray*)&quant24_scale, (TfLiteIntArray*)&quant24_zero, 0 };
const TfArray<4, int> tensor_dimension25 = { 4, { 1,1,17,16 } };
const TfArray<1, float> quant25_scale = { 1, { 0.041602112352848053, } };
const TfArray<1, int> quant25_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant25 = { (TfLiteFloatArray*)&quant25_scale, (TfLiteIntArray*)&quant25_zero, 0 };
const TfArray<4, int> tensor_dimension26 = { 4, { 1,17,1,16 } };
const TfArray<1, float> quant26_scale = { 1, { 0.041602112352848053, } };
const TfArray<1, int> quant26_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant26 = { (TfLiteFloatArray*)&quant26_scale, (TfLiteIntArray*)&quant26_zero, 0 };
const TfArray<4, int> tensor_dimension27 = { 4, { 1,9,1,16 } };
const TfArray<1, float> quant27_scale = { 1, { 0.041602112352848053, } };
const TfArray<1, int> quant27_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant27 = { (TfLiteFloatArray*)&quant27_scale, (TfLiteIntArray*)&quant27_zero, 0 };
const TfArray<4, int> tensor_dimension28 = { 4, { 1,1,9,16 } };
const TfArray<1, float> quant28_scale = { 1, { 0.041602112352848053, } };
const TfArray<1, int> quant28_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant28 = { (TfLiteFloatArray*)&quant28_scale, (TfLiteIntArray*)&quant28_zero, 0 };
const TfArray<4, int> tensor_dimension29 = { 4, { 1,1,9,16 } };
const TfArray<1, float> quant29_scale = { 1, { 0.067887142300605774, } };
const TfArray<1, int> quant29_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant29 = { (TfLiteFloatArray*)&quant29_scale, (TfLiteIntArray*)&quant29_zero, 0 };
const TfArray<4, int> tensor_dimension30 = { 4, { 1,9,1,16 } };
const TfArray<1, float> quant30_scale = { 1, { 0.067887142300605774, } };
const TfArray<1, int> quant30_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant30 = { (TfLiteFloatArray*)&quant30_scale, (TfLiteIntArray*)&quant30_zero, 0 };
const TfArray<4, int> tensor_dimension31 = { 4, { 1,5,1,16 } };
const TfArray<1, float> quant31_scale = { 1, { 0.067887142300605774, } };
const TfArray<1, int> quant31_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant31 = { (TfLiteFloatArray*)&quant31_scale, (TfLiteIntArray*)&quant31_zero, 0 };
const TfArray<4, int> tensor_dimension32 = { 4, { 1,1,5,16 } };
const TfArray<1, float> quant32_scale = { 1, { 0.067887142300605774, } };
const TfArray<1, int> quant32_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant32 = { (TfLiteFloatArray*)&quant32_scale, (TfLiteIntArray*)&quant32_zero, 0 };
const TfArray<4, int> tensor_dimension33 = { 4, { 1,1,5,16 } };
const TfArray<1, float> quant33_scale = { 1, { 0.056417457759380341, } };
const TfArray<1, int> quant33_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant33 = { (TfLiteFloatArray*)&quant33_scale, (TfLiteIntArray*)&quant33_zero, 0 };
const TfArray<4, int> tensor_dimension34 = { 4, { 1,5,1,16 } };
const TfArray<1, float> quant34_scale = { 1, { 0.056417457759380341, } };
const TfArray<1, int> quant34_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant34 = { (TfLiteFloatArray*)&quant34_scale, (TfLiteIntArray*)&quant34_zero, 0 };
const TfArray<4, int> tensor_dimension35 = { 4, { 1,3,1,16 } };
const TfArray<1, float> quant35_scale = { 1, { 0.056417457759380341, } };
const TfArray<1, int> quant35_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant35 = { (TfLiteFloatArray*)&quant35_scale, (TfLiteIntArray*)&quant35_zero, 0 };
const TfArray<2, int> tensor_dimension36 = { 2, { 1,48 } };
const TfArray<1, float> quant36_scale = { 1, { 0.056417457759380341, } };
const TfArray<1, int> quant36_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant36 = { (TfLiteFloatArray*)&quant36_scale, (TfLiteIntArray*)&quant36_zero, 0 };
const TfArray<2, int> tensor_dimension37 = { 2, { 1,5 } };
const TfArray<1, float> quant37_scale = { 1, { 0.17922678589820862, } };
const TfArray<1, int> quant37_zero = { 1, { -20 } };
const TfLiteAffineQuantization quant37 = { (TfLiteFloatArray*)&quant37_scale, (TfLiteIntArray*)&quant37_zero, 0 };
const TfArray<2, int> tensor_dimension38 = { 2, { 1,5 } };
const TfArray<1, float> quant38_scale = { 1, { 0.00390625, } };
const TfArray<1, int> quant38_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant38 = { (TfLiteFloatArray*)&quant38_scale, (TfLiteIntArray*)&quant38_zero, 0 };
const TfLiteReshapeParams opdata0 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs0 = { 2, { 0,1 } };
const TfArray<1, int> outputs0 = { 1, { 20 } };
const TfLiteConvParams opdata1 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs1 = { 3, { 20,19,18 } };
const TfArray<1, int> outputs1 = { 1, { 21 } };
const TfLiteReshapeParams opdata2 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs2 = { 2, { 21,2 } };
const TfArray<1, int> outputs2 = { 1, { 22 } };
const TfLitePoolParams opdata3 = { kTfLitePaddingSame, 1,2, 1,2, kTfLiteActNone, { { 0,0, 0, 0 } } };
const TfArray<1, int> inputs3 = { 1, { 22 } };
const TfArray<1, int> outputs3 = { 1, { 23 } };
const TfLiteReshapeParams opdata4 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs4 = { 2, { 23,3 } };
const TfArray<1, int> outputs4 = { 1, { 24 } };
const TfLiteConvParams opdata5 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs5 = { 3, { 24,17,16 } };
const TfArray<1, int> outputs5 = { 1, { 25 } };
const TfLiteReshapeParams opdata6 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs6 = { 2, { 25,4 } };
const TfArray<1, int> outputs6 = { 1, { 26 } };
const TfLitePoolParams opdata7 = { kTfLitePaddingSame, 1,2, 1,2, kTfLiteActNone, { { 0,0, 0, 0 } } };
const TfArray<1, int> inputs7 = { 1, { 26 } };
const TfArray<1, int> outputs7 = { 1, { 27 } };
const TfLiteReshapeParams opdata8 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs8 = { 2, { 27,5 } };
const TfArray<1, int> outputs8 = { 1, { 28 } };
const TfLiteConvParams opdata9 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs9 = { 3, { 28,15,14 } };
const TfArray<1, int> outputs9 = { 1, { 29 } };
const TfLiteReshapeParams opdata10 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs10 = { 2, { 29,6 } };
const TfArray<1, int> outputs10 = { 1, { 30 } };
const TfLitePoolParams opdata11 = { kTfLitePaddingSame, 1,2, 1,2, kTfLiteActNone, { { 0,0, 0, 0 } } };
const TfArray<1, int> inputs11 = { 1, { 30 } };
const TfArray<1, int> outputs11 = { 1, { 31 } };
const TfLiteReshapeParams opdata12 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs12 = { 2, { 31,7 } };
const TfArray<1, int> outputs12 = { 1, { 32 } };
const TfLiteConvParams opdata13 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs13 = { 3, { 32,13,12 } };
const TfArray<1, int> outputs13 = { 1, { 33 } };
const TfLiteReshapeParams opdata14 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs14 = { 2, { 33,8 } };
const TfArray<1, int> outputs14 = { 1, { 34 } };
const TfLitePoolParams opdata15 = { kTfLitePaddingSame, 1,2, 1,2, kTfLiteActNone, { { 0,0, 0, 0 } } };
const TfArray<1, int> inputs15 = { 1, { 34 } };
const TfArray<1, int> outputs15 = { 1, { 35 } };
const TfLiteReshapeParams opdata16 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs16 = { 2, { 35,9 } };
const TfArray<1, int> outputs16 = { 1, { 36 } };
const TfLiteFullyConnectedParams opdata17 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs17 = { 3, { 36,11,10 } };
const TfArray<1, int> outputs17 = { 1, { 37 } };
const TfLiteSoftmaxParams opdata18 = { 1 };
const TfArray<1, int> inputs18 = { 1, { 37 } };
const TfArray<1, int> outputs18 = { 1, { 38 } };
};

TensorInfo_t tensorData[] = {
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 432), (TfLiteIntArray*)&g0::tensor_dimension0, 429, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant0))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data1, (TfLiteIntArray*)&g0::tensor_dimension1, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data2, (TfLiteIntArray*)&g0::tensor_dimension2, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data3, (TfLiteIntArray*)&g0::tensor_dimension3, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data4, (TfLiteIntArray*)&g0::tensor_dimension4, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data5, (TfLiteIntArray*)&g0::tensor_dimension5, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data6, (TfLiteIntArray*)&g0::tensor_dimension6, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data7, (TfLiteIntArray*)&g0::tensor_dimension7, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data8, (TfLiteIntArray*)&g0::tensor_dimension8, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data9, (TfLiteIntArray*)&g0::tensor_dimension9, 8, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data10, (TfLiteIntArray*)&g0::tensor_dimension10, 20, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant10))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data11, (TfLiteIntArray*)&g0::tensor_dimension11, 240, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant11))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data12, (TfLiteIntArray*)&g0::tensor_dimension12, 64, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant12))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data13, (TfLiteIntArray*)&g0::tensor_dimension13, 1024, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant13))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data14, (TfLiteIntArray*)&g0::tensor_dimension14, 64, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant14))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data15, (TfLiteIntArray*)&g0::tensor_dimension15, 1024, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant15))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data16, (TfLiteIntArray*)&g0::tensor_dimension16, 64, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant16))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data17, (TfLiteIntArray*)&g0::tensor_dimension17, 768, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant17))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data18, (TfLiteIntArray*)&g0::tensor_dimension18, 64, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant18))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data19, (TfLiteIntArray*)&g0::tensor_dimension19, 624, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant19))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension20, 429, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant20))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 528), (TfLiteIntArray*)&g0::tensor_dimension21, 528, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant21))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension22, 528, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant22))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 528), (TfLiteIntArray*)&g0::tensor_dimension23, 272, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant23))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension24, 272, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant24))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 272), (TfLiteIntArray*)&g0::tensor_dimension25, 272, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant25))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension26, 272, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant26))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 544), (TfLiteIntArray*)&g0::tensor_dimension27, 144, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant27))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 400), (TfLiteIntArray*)&g0::tensor_dimension28, 144, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant28))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 256), (TfLiteIntArray*)&g0::tensor_dimension29, 144, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant29))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension30, 144, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant30))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 144), (TfLiteIntArray*)&g0::tensor_dimension31, 80, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant31))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 336), (TfLiteIntArray*)&g0::tensor_dimension32, 80, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant32))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 256), (TfLiteIntArray*)&g0::tensor_dimension33, 80, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant33))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension34, 80, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant34))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 80), (TfLiteIntArray*)&g0::tensor_dimension35, 48, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant35))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension36, 48, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant36))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 48), (TfLiteIntArray*)&g0::tensor_dimension37, 5, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant37))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension38, 5, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant38))}, },
};

#ifndef TF_LITE_STATIC_MEMORY
TfLiteNode tflNodes[19] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs4, (TfLiteIntArray*)&g0::outputs4, (TfLiteIntArray*)&g0::inputs4, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata4)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs5, (TfLiteIntArray*)&g0::outputs5, (TfLiteIntArray*)&g0::inputs5, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata5)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs6, (TfLiteIntArray*)&g0::outputs6, (TfLiteIntArray*)&g0::inputs6, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata6)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs7, (TfLiteIntArray*)&g0::outputs7, (TfLiteIntArray*)&g0::inputs7, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata7)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs8, (TfLiteIntArray*)&g0::outputs8, (TfLiteIntArray*)&g0::inputs8, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata8)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs9, (TfLiteIntArray*)&g0::outputs9, (TfLiteIntArray*)&g0::inputs9, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata9)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs10, (TfLiteIntArray*)&g0::outputs10, (TfLiteIntArray*)&g0::inputs10, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata10)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs11, (TfLiteIntArray*)&g0::outputs11, (TfLiteIntArray*)&g0::inputs11, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata11)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs12, (TfLiteIntArray*)&g0::outputs12, (TfLiteIntArray*)&g0::inputs12, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata12)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs13, (TfLiteIntArray*)&g0::outputs13, (TfLiteIntArray*)&g0::inputs13, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata13)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs14, (TfLiteIntArray*)&g0::outputs14, (TfLiteIntArray*)&g0::inputs14, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata14)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs15, (TfLiteIntArray*)&g0::outputs15, (TfLiteIntArray*)&g0::inputs15, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata15)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs16, (TfLiteIntArray*)&g0::outputs16, (TfLiteIntArray*)&g0::inputs16, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata16)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs17, (TfLiteIntArray*)&g0::outputs17, (TfLiteIntArray*)&g0::inputs17, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata17)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs18, (TfLiteIntArray*)&g0::outputs18, (TfLiteIntArray*)&g0::inputs18, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata18)), nullptr, 0, },
};
#else
TfLiteNode tflNodes[19] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs4, (TfLiteIntArray*)&g0::outputs4, (TfLiteIntArray*)&g0::inputs4, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata4)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs5, (TfLiteIntArray*)&g0::outputs5, (TfLiteIntArray*)&g0::inputs5, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata5)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs6, (TfLiteIntArray*)&g0::outputs6, (TfLiteIntArray*)&g0::inputs6, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata6)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs7, (TfLiteIntArray*)&g0::outputs7, (TfLiteIntArray*)&g0::inputs7, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata7)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs8, (TfLiteIntArray*)&g0::outputs8, (TfLiteIntArray*)&g0::inputs8, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata8)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs9, (TfLiteIntArray*)&g0::outputs9, (TfLiteIntArray*)&g0::inputs9, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata9)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs10, (TfLiteIntArray*)&g0::outputs10, (TfLiteIntArray*)&g0::inputs10, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata10)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs11, (TfLiteIntArray*)&g0::outputs11, (TfLiteIntArray*)&g0::inputs11, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata11)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs12, (TfLiteIntArray*)&g0::outputs12, (TfLiteIntArray*)&g0::inputs12, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata12)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs13, (TfLiteIntArray*)&g0::outputs13, (TfLiteIntArray*)&g0::inputs13, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata13)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs14, (TfLiteIntArray*)&g0::outputs14, (TfLiteIntArray*)&g0::inputs14, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata14)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs15, (TfLiteIntArray*)&g0::outputs15, (TfLiteIntArray*)&g0::inputs15, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata15)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs16, (TfLiteIntArray*)&g0::outputs16, (TfLiteIntArray*)&g0::inputs16, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata16)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs17, (TfLiteIntArray*)&g0::outputs17, (TfLiteIntArray*)&g0::inputs17, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata17)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs18, (TfLiteIntArray*)&g0::outputs18, (TfLiteIntArray*)&g0::inputs18, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata18)), nullptr, 0, },
};
#endif

used_operators_e used_ops[] =
{OP_RESHAPE, OP_CONV_2D, OP_RESHAPE, OP_MAX_POOL_2D, OP_RESHAPE, OP_CONV_2D, OP_RESHAPE, OP_MAX_POOL_2D, OP_RESHAPE, OP_CONV_2D, OP_RESHAPE, OP_MAX_POOL_2D, OP_RESHAPE, OP_CONV_2D, OP_RESHAPE, OP_MAX_POOL_2D, OP_RESHAPE, OP_FULLY_CONNECTED, OP_SOFTMAX, };


// Indices into tflTensors and tflNodes for subgraphs
const size_t tflTensors_subgraph_index[] = {0, 39, };
const size_t tflNodes_subgraph_index[] = {0, 19, };

// Input/output tensors
static const int in_tensor_indices[] = {
  0, 
};

static const int out_tensor_indices[] = {
  38, 
};


size_t current_subgraph_index = 0;

static void init_tflite_tensor(size_t i, TfLiteTensor *tensor) {
  tensor->type = tensorData[i].type;
  tensor->is_variable = false;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  tensor->allocation_type = tensorData[i].allocation_type;
#else
  tensor->allocation_type = (tensor_arena <= tensorData[i].data && tensorData[i].data < tensor_arena + kTensorArenaSize) ? kTfLiteArenaRw : kTfLiteMmapRo;
#endif
  tensor->bytes = tensorData[i].bytes;
  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  if(tensor->allocation_type == kTfLiteArenaRw){
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
      tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
  tensor->quantization = tensorData[i].quantization;
  if (tensor->quantization.type == kTfLiteAffineQuantization) {
    TfLiteAffineQuantization const* quant = ((TfLiteAffineQuantization const*)(tensorData[i].quantization.params));
    tensor->params.scale = quant->scale->data[0];
    tensor->params.zero_point = quant->zero_point->data[0];
  }

}

static void init_tflite_eval_tensor(int i, TfLiteEvalTensor *tensor) {

  tensor->type = tensorData[i].type;

  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  auto allocation_type = tensorData[i].allocation_type;
  if(allocation_type == kTfLiteArenaRw) {
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
    tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
}

static void* overflow_buffers[EI_MAX_OVERFLOW_BUFFER_COUNT];
static size_t overflow_buffers_ix = 0;
static void * AllocatePersistentBufferImpl(struct TfLiteContext* ctx,
                                       size_t bytes) {
  void *ptr;
  uint32_t align_bytes = (bytes % 16) ? 16 - (bytes % 16) : 0;

  if (current_location - (bytes + align_bytes) < tensor_boundary) {
    if (overflow_buffers_ix > EI_MAX_OVERFLOW_BUFFER_COUNT - 1) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d, does not fit in tensor arena and reached EI_MAX_OVERFLOW_BUFFER_COUNT\n",
        (int)bytes);
      return NULL;
    }

    // OK, this will look super weird, but.... we have CMSIS-NN buffers which
    // we cannot calculate beforehand easily.
    ptr = ei_calloc(bytes, 1);
    if (ptr == NULL) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d\n", (int)bytes);
      return NULL;
    }
    overflow_buffers[overflow_buffers_ix++] = ptr;
    return ptr;
  }

  current_location -= bytes;

  // align to the left aligned boundary of 16 bytes
  current_location -= 15; // for alignment
  current_location += 16 - ((uintptr_t)(current_location) & 15);

  ptr = current_location;
  memset(ptr, 0, bytes);

  return ptr;
}

typedef struct {
  size_t bytes;
  void *ptr;
} scratch_buffer_t;

static scratch_buffer_t scratch_buffers[EI_MAX_SCRATCH_BUFFER_COUNT];
static size_t scratch_buffers_ix = 0;

static TfLiteStatus RequestScratchBufferInArenaImpl(struct TfLiteContext* ctx, size_t bytes,
                                                int* buffer_idx) {
  if (scratch_buffers_ix > EI_MAX_SCRATCH_BUFFER_COUNT - 1) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d, reached EI_MAX_SCRATCH_BUFFER_COUNT\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffer_t b;
  b.bytes = bytes;

  b.ptr = AllocatePersistentBufferImpl(ctx, b.bytes);
  if (!b.ptr) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffers[scratch_buffers_ix] = b;
  *buffer_idx = scratch_buffers_ix;

  scratch_buffers_ix++;

  return kTfLiteOk;
}

static void* GetScratchBufferImpl(struct TfLiteContext* ctx, int buffer_idx) {
  if (buffer_idx > (int)scratch_buffers_ix) {
    return NULL;
  }
  return scratch_buffers[buffer_idx].ptr;
}

static const uint16_t TENSOR_IX_UNUSED = 0x7FFF;

static void ResetTensors() {
  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    tflTensors[ix].index = TENSOR_IX_UNUSED;
  }
  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    tflEvalTensors[ix].index = TENSOR_IX_UNUSED;
  }
}

static TfLiteTensor* GetTensorImpl(const struct TfLiteContext* context,
                               int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    // already used? OK!
    if (tflTensors[ix].index == tensor_idx) {
      return &tflTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_tensor(tensor_idx, &tflTensors[ix].tensor);
      tflTensors[ix].index = tensor_idx;
      return &tflTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_TENSOR_COUNT (%d)\n", MAX_TFL_TENSOR_COUNT);
  return nullptr;
}

static TfLiteEvalTensor* GetEvalTensorImpl(const struct TfLiteContext* context,
                                       int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    // already used? OK!
    if (tflEvalTensors[ix].index == tensor_idx) {
      return &tflEvalTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflEvalTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_eval_tensor(tensor_idx, &tflEvalTensors[ix].tensor);
      tflEvalTensors[ix].index = tensor_idx;
      return &tflEvalTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_EVAL_COUNT (%d)\n", (int)MAX_TFL_EVAL_COUNT);
  return nullptr;
}

class EonMicroContext : public MicroContext {
 public:
 
  EonMicroContext(): MicroContext(nullptr, nullptr, nullptr) { }

  void* AllocatePersistentBuffer(size_t bytes) {
    return AllocatePersistentBufferImpl(nullptr, bytes);
  }

  TfLiteStatus RequestScratchBufferInArena(size_t bytes,
                                           int* buffer_index) {
  return RequestScratchBufferInArenaImpl(nullptr, bytes, buffer_index);
  }

  void* GetScratchBuffer(int buffer_index) {
    return GetScratchBufferImpl(nullptr, buffer_index);
  }
 
  TfLiteTensor* AllocateTempTfLiteTensor(int tensor_index) {
    return GetTensorImpl(nullptr, tensor_index);
  }

  void DeallocateTempTfLiteTensor(TfLiteTensor* tensor) {
    return;
  }

  bool IsAllTempTfLiteTensorDeallocated() {
    return true;
  }

  TfLiteEvalTensor* GetEvalTensor(int tensor_index) {
    return GetEvalTensorImpl(nullptr, tensor_index);
  }

};


} // namespace

TfLiteStatus tflite_learn_20_init( void*(*alloc_fnc)(size_t,size_t) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  tensor_arena = (uint8_t*) alloc_fnc(16, kTensorArenaSize);
  if (!tensor_arena) {
    ei_printf("ERR: failed to allocate tensor arena\n");
    return kTfLiteError;
  }
#else
  memset(tensor_arena, 0, kTensorArenaSize);
#endif
  tensor_boundary = tensor_arena;
  current_location = tensor_arena + kTensorArenaSize;

  EonMicroContext micro_context_;
  
  // Set microcontext as the context ptr
  ctx.impl_ = static_cast<void*>(&micro_context_);
  // Setup tflitecontext functions
  ctx.AllocatePersistentBuffer = &AllocatePersistentBufferImpl;
  ctx.RequestScratchBufferInArena = &RequestScratchBufferInArenaImpl;
  ctx.GetScratchBuffer = &GetScratchBufferImpl;
  ctx.GetTensor = &GetTensorImpl;
  ctx.GetEvalTensor = &GetEvalTensorImpl;
  ctx.ReportError = &MicroContextReportOpError;

  ctx.tensors_size = 39;
  for (size_t i = 0; i < 39; ++i) {
    TfLiteTensor tensor;
    init_tflite_tensor(i, &tensor);
    if (tensor.allocation_type == kTfLiteArenaRw) {
      auto data_end_ptr = (uint8_t*)tensor.data.data + tensorData[i].bytes;
      if (data_end_ptr > tensor_boundary) {
        tensor_boundary = data_end_ptr;
      }
    }
  }

  if (tensor_boundary > current_location /* end of arena size */) {
    ei_printf("ERR: tensor arena is too small, does not fit model - even without scratch buffers\n");
    return kTfLiteError;
  }

  registrations[OP_RESHAPE] = Register_RESHAPE();
  registrations[OP_CONV_2D] = Register_CONV_2D();
  registrations[OP_MAX_POOL_2D] = Register_MAX_POOL_2D();
  registrations[OP_FULLY_CONNECTED] = Register_FULLY_CONNECTED();
  registrations[OP_SOFTMAX] = Register_SOFTMAX();

  for (size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].init) {
        tflNodes[i].user_data = registrations[used_ops[i]].init(&ctx, (const char*)tflNodes[i].builtin_data, 0);
      }
    }
  }
  current_subgraph_index = 0;

  for(size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].prepare) {
        ResetTensors();
        TfLiteStatus status = registrations[used_ops[i]].prepare(&ctx, &tflNodes[i]);
        if (status != kTfLiteOk) {
          return status;
        }
      }
    }
  }
  current_subgraph_index = 0;

  return kTfLiteOk;
}

TfLiteStatus tflite_learn_20_input(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(in_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_20_output(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(out_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_20_invoke() {
  for (size_t i = 0; i < 19; ++i) {
    ResetTensors();

    TfLiteStatus status = registrations[used_ops[i]].invoke(&ctx, &tflNodes[i]);

#if EI_CLASSIFIER_PRINT_STATE
    ei_printf("layer %lu\n", i);
    ei_printf("    inputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].inputs->size; ix++) {
      auto d = tensorData[tflNodes[i].inputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");

    ei_printf("    outputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].outputs->size; ix++) {
      auto d = tensorData[tflNodes[i].outputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");
#endif // EI_CLASSIFIER_PRINT_STATE

    if (status != kTfLiteOk) {
      return status;
    }
  }
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_20_reset( void (*free_fnc)(void* ptr) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  free_fnc(tensor_arena);
#endif

  // scratch buffers are allocated within the arena, so just reset the counter so memory can be reused
  scratch_buffers_ix = 0;

  // overflow buffers are on the heap, so free them first
  for (size_t ix = 0; ix < overflow_buffers_ix; ix++) {
    ei_free(overflow_buffers[ix]);
  }
  overflow_buffers_ix = 0;
  return kTfLiteOk;
}
